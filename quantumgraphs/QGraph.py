#     Copyright (C) 2020 Miatto research group.

#     This program is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.

#     This program is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.

#     You should have received a copy of the GNU General Public License
#     along with this program.  If not, see <https://www.gnu.org/licenses/>.

import numpy as np
import networkx as nx
import scipy as sp
from collections import defaultdict
from numbers import Real
import matplotlib.pyplot as plt
from pathlib import Path


class QGraph:
    """
    A class for Quantum Graphs, which are graphs with a given number of associate quantum walkers.
    The quantum walkers evolve unitarily on the graph and their wave function spreads on the nodes.
    The graphs can be grown by alternating evolution and collapse of the walkers: the evolution is
    continuous and is generated by the adjacency matrix of the graph as Hamiltonian. After a random time
    sampled from the exponential distribution, the walkers are collapsed onto random nodes.
    At each collapse a new node is attached to all the nodes where the walkers collapsed.
    This procedure can be repeated N times to add N new nodes. 

    The QGraph class supplies a number of helper functions to save/load a graph, compute its properties
    (diameter, clustering coefficient, etc...), draw the graph and export the drawing.
    """
    def __init__(self, walkers: int = 1, exploration: Real = 0.1):
        self.exploration = exploration
        self.walkers = walkers
        self.wave_functions = np.ones([self.walkers, 1], dtype=np.complex64)
        self.adjacency_matrix_ = sp.sparse.coo_matrix(([0], ([0], [0])))
        
        # coo_matrix data for sparse adjacency matrix
        self.data = [0]
        self.row = [0]
        self.col = [0]

        # lazy properties
        self.clustering_coefficient_ = None
        self.diameter_ = None
        self.leaf_fraction_ = None
        self.degree_distribution_ = None

    def __hash__(self):
        return hash(tuple(self.adjacency_matrix.reshape(-1)))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        return hash(self) == hash(other)

    def __repr__(self):
        return f'QGraph(walkers={self.walkers}, exploration={self.exploration}) with {self.nodes} nodes'

    @property
    def adjacency_matrix(self):
        if self.adjacency_matrix_ is None:
            self.adjacency_matrix_ = sp.sparse.coo_matrix((self.data, (self.row,self.col)))
        return self.adjacency_matrix_

    @property
    def nodes(self):
        return self.adjacency_matrix.shape[0]
    
    @property
    def sample_position(self):
        # sampling walker's position without collapsing the wave function
        probs = abs(self.wave_functions)**2
        return [int(np.random.choice(range(self.nodes), p=p)) for p in probs]
    
    @property
    def _random_time(self):
        "Returns a random time sampled from Exp(exploration)"
        np.random.seed()
        return np.random.exponential(self.exploration)
    
    @property
    def graph(self):
        "Returns the networkx object of the graph"
        return nx.from_scipy_sparse_matrix(self.adjacency_matrix)

    @property
    def clustering_coefficient(self):
        if self.walkers == 1:
            return 0
        if not self.clustering_coefficient_:
            self.clustering_coefficient_ = nx.average_clustering(self.graph)
        return self.clustering_coefficient_

    @property
    def diameter(self):
        if not self.diameter_:
            self.diameter_ = nx.diameter(self.graph)
        return self.diameter_

    @property
    def degree_distribution(self):
        if not self.degree_distribution_:
            degrees = sorted([d[1] for d in self.graph.degree()], reverse=True)
            counter = defaultdict(int)
            for d in degrees:
                counter[d] += 1
            self.degree_distribution_ = [counter[n]/self.nodes for n in range(1, self.nodes)]
        return self.degree_distribution_

    @property
    def leaf_fraction(self):
        return self.degree_distribution[0]

    def _collapse_walkers(self):
        """
        Measures the position of all walkers and collapses the wave functions
        """
        pos = self.sample_position
        z = np.zeros([self.walkers, self.nodes], dtype=np.complex64)
        for w,p in enumerate(pos):
            z[w,p] = 1
        self.wave_functions = z
        return pos
    
    def _evolve(self):
        """
        Samples a random time from Exp(self.exploration)
        and evolves all the wave functions accordingly
        """
        if not np.isclose(np.sum(abs(self.wave_functions)), self.walkers):
            raise RuntimeError('walkers not collapsed')
        
        H = self.adjacency_matrix
        t = self._random_time
        
        for k,wf in enumerate(self.wave_functions):
            self.wave_functions[k] = sp.sparse.linalg.expm_multiply(1j*t*H, wf)
        
    def add_nodes(self, nodes: int = 1):
        """
        Adds the specified number of nodes to the graph by alternating evolution 
        and collapse of the walkers. Also resets the graph's properties as they need 
        to be recomputed.

        Arguments: nodes (int)
        """
        for _ in range(nodes):
            self._evolve()
            pos = self._collapse_walkers()

            self.wave_functions = np.pad(self.wave_functions, ((0,0),(0,1)))

            self.data += [1,1]*self.walkers
            self.row += [self.nodes]*self.walkers + pos
            self.col += pos + [self.nodes]*self.walkers
            self.adjacency_matrix_ = None
        
        # reset lazy properties        
        self.diameter_ = None
        self.degree_distribution_ = None
        self.leaf_fraction_ = None
        self.clustering_coefficient_ = None

    def draw(self, figsize = (5,5), filename = None, **kwargs):
        """
        Draws the current graph using networkx and the Kamada-Kawai embedding.

        Arguments:
            figsize (int,int): the size of the figure
            **kwargs: keyword arguments that we wish to pass to `draw_kamada_kawai()`
        """
        if 'ax' not in kwargs:
            f = plt.figure(figsize=figsize)
            ax = f.add_subplot(111)
            ax.set_aspect('equal')
            kwargs['ax'] = ax
        nx.drawing.nx_pylab.draw_kamada_kawai(self.graph, **kwargs)

        if filename:
            f.savefig(filename, bbox_inches='tight')
            print(f'saved figure as {Path().absolute()}/'+filename)
        
